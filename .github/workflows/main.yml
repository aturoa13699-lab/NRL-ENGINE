#!/usr/bin/env python3
"""
NRL SCRAPER - Railway Worker Entrypoint

Usage (Railway variables):
  MODE=season|historical              # default: season
  SEASON=2024                         # when MODE=season
  INCLUDE_FINALS=1|0                  # default: 1
  WRITE_DB=1|0                        # default: 0 (set to 1 to upsert into Postgres)
  DATABASE_URL=postgresql+psycopg://...  # required when WRITE_DB=1
  EXPORT=0|1                          # default: 0 (container FS is ephemeral on Railway)
  START_YEAR=1998                     # when MODE=historical
  END_YEAR=2025                       # when MODE=historical

Exit codes:
  0 = success
  1 = runtime failure
  2 = invalid configuration
"""

from __future__ import annotations

import json
import logging
import os
import signal
import sys
from datetime import datetime
from typing import Any, Dict, List, Optional

_SHUTDOWN = False


# ---------------------------
# Logging (JSON lines)
# ---------------------------
class _JsonFormatter(logging.Formatter):
    def format(self, record: logging.LogRecord) -> str:
        payload = {
            "ts": datetime.utcnow().isoformat(timespec="seconds") + "Z",
            "level": record.levelname,
            "msg": record.getMessage(),
            "logger": record.name,
        }
        # Include selected extras if present
        for key in ("mode", "season", "start_year", "end_year", "include_finals", "write_db", "export"):
            if hasattr(record, key):
                payload[key] = getattr(record, key)
        if record.exc_info:
            payload["exc"] = self.formatException(record.exc_info)
        return json.dumps(payload, ensure_ascii=False)


def _setup_logging() -> None:
    root = logging.getLogger()
    root.setLevel(logging.INFO)
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(_JsonFormatter())
    root.handlers[:] = [handler]


# ---------------------------
# Utils
# ---------------------------
def _parse_bool(val: Optional[str], default: bool = False) -> bool:
    if val is None:
        return default
    s = val.strip().lower()
    return s in ("1", "true", "t", "yes", "y", "on")


def _int_env(name: str, default: Optional[int] = None) -> Optional[int]:
    raw = os.getenv(name)
    if raw is None or raw.strip() == "":
        return default
    try:
        return int(raw.strip())
    except ValueError:
        logging.error("invalid integer for env", extra={"env": name, "value": raw})
        return default


def _require(cond: bool, msg: str) -> None:
    if not cond:
        logging.error("configuration error: %s", msg)
        sys.exit(2)


# ---------------------------
# Orchestration
# ---------------------------
def run_season_scrape(season: int, include_finals: bool, write_db: bool, export: bool) -> int:
    """
    Scrape a single season; optionally upsert to DB and/or export Parquet.
    """
    from nrlscraper import NRLScraper  # lazy import
    logging.info(
        "starting season scrape",
        extra={"season": season, "include_finals": include_finals, "write_db": write_db, "export": export},
    )

    scraper = NRLScraper()
    rows: List[Dict[str, Any]] = scraper.scrape_season(season, include_finals=include_finals)  # type: ignore[assignment]

    total = len(rows)
    logging.info("scrape complete", extra={"season": season, "total": total})

    if write_db:
        _write_matches_to_db(rows)

    if export:
        _export_matches(rows, table="matches", season=season)

    logging.info("season done", extra={"season": season, "total": total})
    return 0


def run_historical_scrape(start_year: int, end_year: int, include_finals: bool, write_db: bool, export: bool) -> int:
    """
    Scrape seasons in [start_year, end_year]; optionally upsert to DB and/or export Parquet.
    """
    _require(start_year <= end_year, f"START_YEAR ({start_year}) must be <= END_YEAR ({end_year})")
    overall = 0
    for year in range(start_year, end_year + 1):
        if _SHUTDOWN:
            logging.warning("shutdown signal received; stopping historical loop")
            break
        rc = run_season_scrape(year, include_finals=include_finals, write_db=write_db, export=export)
        if rc != 0:
            logging.error("season scrape failed", extra={"season": year})
            return rc
        overall += 1
    logging.info("historical scrape complete", extra={"start_year": start_year, "end_year": end_year, "seasons": overall})
    return 0


def _write_matches_to_db(rows: List[Dict[str, Any]]) -> None:
    """
    Upsert match rows into Postgres using project-provided db helpers.
    Requires DATABASE_URL to be set (psycopg3).
    """
    dsn = os.getenv("DATABASE_URL")
    _require(bool(dsn), "WRITE_DB=1 requires DATABASE_URL to be set")
    from nrlscraper.db import init_engine, upsert_matches  # lazy import

    engine = init_engine(dsn=dsn)  # type: ignore[arg-type]
    upsert_matches(engine, rows)    # type: ignore[arg-type]
    logging.info("db upsert complete", extra={"rows": len(rows)})


def _export_matches(rows: List[Dict[str, Any]], table: str, season: int) -> None:
    """
    Write Parquet to local path (ephemeral on Railway). Uses whichever export function is available.
    """
    # Support both old and new export function names
    try:
        from nrlscraper.export import to_parquet as _export_fn  # type: ignore[attr-defined]
    except Exception:
        try:
            from nrlscraper.export import export_to_parquet as _export_fn  # type: ignore[attr-defined]
        except Exception:
            logging.error("no export function found in nrlscraper.export (to_parquet/export_to_parquet)")
            return
    out_path = _export_fn(rows, table=table, season=season)
    logging.info("parquet export complete", extra={"path": out_path, "rows": len(rows), "season": season})


def _install_signal_handlers() -> None:
    def _sigterm(_signum, _frame):
        global _SHUTDOWN
        _SHUTDOWN = True
        logging.warning("received termination signal; will stop after current task")

    for sig in (signal.SIGINT, signal.SIGTERM):
        signal.signal(sig, _sigterm)


def main() -> int:
    _setup_logging()
    _install_signal_handlers()

    # Banner (one line so it doesn't spam logs)
    logging.info("NRL SCRAPER - Railway Worker")

    mode = os.getenv("MODE", "season").strip().lower()
    include_finals = _parse_bool(os.getenv("INCLUDE_FINALS"), True)
    write_db = _parse_bool(os.getenv("WRITE_DB"), False)
    export = _parse_bool(os.getenv("EXPORT"), False)

    if mode == "season":
        season = _int_env("SEASON")
        _require(season is not None, "MODE=season requires SEASON")
        logging.info(
            "configuration",
            extra={"mode": mode, "season": season, "include_finals": include_finals, "write_db": write_db, "export": export},
        )
        return run_season_scrape(int(season), include_finals, write_db, export)

    elif mode == "historical":
        # accept either START_YEAR/END_YEAR or START/END for convenience
        start_year = _int_env("START_YEAR", _int_env("START"))
        end_year = _int_env("END_YEAR", _int_env("END"))
        _require(start_year is not None and end_year is not None, "MODE=historical requires START_YEAR and END_YEAR")
        logging.info(
            "configuration",
            extra={
                "mode": mode,
                "start_year": start_year,
                "end_year": end_year,
                "include_finals": include_finals,
                "write_db": write_db,
                "export": export,
            },
        )
        return run_historical_scrape(int(start_year), int(end_year), include_finals, write_db, export)

    else:
        logging.error("unknown MODE", extra={"mode": mode})
        return 2


if __name__ == "__main__":
    try:
        code = main()
    except Exception:
        logging.getLogger(__name__).exception("FAILED: unhandled exception")
        code = 1
    # Ensure a final line for logs collectors
    if code == 0:
        logging.info("worker exiting successfully")
    else:
        logging.error("worker exiting with error", extra={"exit_code": code})
    sys.exit(code)
